# ADA 05 
En esta actividad investigamos y presentamos el funcionamiento del Insertion Sort, perteneciente a la categoría de Ordenamiento por Inserción. El objetivo fue desglosar este algoritmo que, aunque sencillo, tiene propiedades teóricas muy interesantes.La tarea consistió en explicar su lógica natural, a menudo comparada con la forma en que ordenamos una baraja de cartas en la mano: se toma un elemento y se compara hacia atrás con los ya ordenados, desplazándolos hasta encontrar su posición correcta.Analizamos sus características técnicas, confirmando que es un algoritmo estable (mantiene el orden relativo de elementos iguales) e in-place (no requiere memoria extra significativa). También estudiamos su eficiencia, contrastando su comportamiento cuadrático $O(n^2)$ en el caso promedio contra su comportamiento lineal $O(n)$ en el mejor caso (cuando la lista ya está casi ordenada).ShutterstockReflexión Personal¿Qué se aprendió?Aprendí que no todos los algoritmos $O(n^2)$ son iguales. Descubrí que el Insertion Sort es increíblemente eficiente para listas pequeñas o parcialmente ordenadas (adaptabilidad), superando incluso a algoritmos más complejos como Quick Sort en esos escenarios específicos. Entendí la diferencia clave entre "intercambiar" (swap) y "desplazar" (shift); este algoritmo prefiere desplazar los elementos mayores a la derecha para abrir espacio, lo cual es distinto a los intercambios constantes del Bubble Sort.Problemas y desafíos:El mayor reto fue entender y explicar visualmente el proceso de desplazamiento dentro del ciclo while. Al principio confundía la lógica con el Selection Sort, pero al analizarlo paso a paso noté que en el Insertion Sort el sub-arreglo izquierdo siempre está ordenado relativamente entre sí, pero no es definitivo (pueden llegar elementos menores después).También fue interesante analizar por qué es malo para listas grandes invertidas; ver cómo cada nuevo elemento obliga a mover todos los anteriores me ayudó a visualizar por qué su costo computacional crece tanto.
